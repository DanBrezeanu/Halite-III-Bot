from hlt import Position
from hlt import Direction

def free_ships_collided(ships, return_status, marked_map):
    """
    Frees return_status for ships that got destroyed and frees map cells that
    were reserved for those destroyed ships
    :param ships: the list of ships
    :return_status: the dictionary formed of tuples ('Free'/'Collecting'/'Ending', Position())
    :marked_map: map filled with cluster.FREE or cluster.RESERVED
    :return: the new return_status dictionary
    """
    ship_exists = [False for _ in range(500)]
    for ship in ships:                          # marcheaza ship-urile care exista (dupa id unic global)
        ship_exists[ship.id] = True

    for i in range(500):
        if not ship_exists[i]:                      #daca nu exista
            if return_status[str(i)][0] != "Free":  # o eliberam
                marked_map[return_status[str(i)][1].x][return_status[str(i)][1].y] = 0 # eliberam si harta
            return_status[str(i)] = ("Free", Position(0,0))

    return return_status

def is_conflict(position_queue):
    """
    Checks whether a conflict exists. A conflict represents the move of two or
    more ships in the same cells
    :param position_queue: list containing Position objects of the new position of each ship
    :return: boolean value of conflict existance
    """
    for pos_index, pos in enumerate(position_queue):
        if pos in position_queue[pos_index + 1:]:     # daca exista aceeasi pozitie si in continuarea listei
            return True

    return False

def choose_direction_no_conflict(ship_index, position_queue, direction_queue, ships):
    """
    Chooses a direction for which there happens no conflicts. If there is no such direction
    it returns Still
    :param ship_index: index of the ship reporting to position_queue
    :param position_queue: list containing Position objects of the new position of each ship
    :param direction_queue: list containing Direction objects of this turn ships' moves
    :param ships: the ships' list
    :return value: Direction object
    """
    for diri in [Direction.North, Direction.South, Direction.West, Direction.East]:      # modifica direction_queue[ship_index]
        direction_queue[ship_index] = diri                                               # cu una din cele 4 directii
        position_queue[ship_index] = ships[ship_index].position.directional_offset(diri)

        if not is_conflict(position_queue):                                              # astfel incat sa nu se genereze conflicte
            return diri

    return Direction.Still                                                               # daca nicio directie nu e buna

def resolve_conflicts(direction_queue, ships):
    """
    Resolves conflicts generated by this turn's moves.  A conflict represents the move of two or
    more ships in the same cells
    :param direction_queue: a list containing the direction of all ships' moves
    :param ships: the ships' list
    :return: a new direction_queue which generates no conflicts
    """
    position_queue = [] # lista cu pozitiile finale ale ship-urilor

    for ship_index, ship in reversed(list(enumerate(ships))): # populeaza position_queue
        position_current = ship.position.directional_offset(direction_queue[ship_index])
        position_queue.insert(0, position_current)

    while is_conflict(position_queue):   # cat timp exista conflicte
        conflict_resolved = False

        for i in range(len(position_queue)):
            if conflict_resolved:       # daca s-a rezolvat conflictul curent, se verifica pentru alt conflict
                break

            for j in range(i + 1, len(position_queue)):
                if position_queue[i] == position_queue[j]:     # s-a gasit un conflict
                    if direction_queue[i] == Direction.Still:  # daca primul ship sta
                        direction_queue[j] = choose_direction_no_conflict(j, position_queue, direction_queue, ships)
                        position_queue[j] = ships[j].position.directional_offset(direction_queue[j]) # atunci al doilea se misca in alta directie

                    elif direction_queue[j] == Direction.Still: # daca al doilea sta
                        direction_queue[i] = choose_direction_no_conflict(i, position_queue, direction_queue, ships)
                        position_queue[i] = ships[i].position.directional_offset(direction_queue[i]) # atunci primul se misca in alta directie

                    else:                                       # daca ambele se misca
                        direction_queue[j] = Direction.Still    # atunci a doua sta
                        position_queue[j] = ships[j].position.directional_offset(direction_queue[i])
                    conflict_resolved = True

                if conflict_resolved:
                    break
    return direction_queue

# def ending_game(direction_queue, ships):
